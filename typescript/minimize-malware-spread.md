[Leetcode Problem 924: Minimize Malware Spread](https://leetcode.com/problems/minimize-malware-spread/)

## Approaches
- [Approach 1: Brute Force and Simulation](#approach-1-brute-force-and-simulation)
- [Approach 2: Union-Find to Identify Connected Components](#approach-2-union-find-to-identify-connected-components)
- [Approach 3: Optimal Simulation with Influence Counting](#approach-3-optimal-simulation-with-influence-counting)

### Approach 1: Brute Force and Simulation

**Intuition**:  
The idea here is to simulate what happens when each node marked as an initial infection is removed. For each removal, we'll simulate the spread of the malware and calculate the number of nodes that actually end up being infected when we remove that particular node.

**Algorithm**:  
1. For each node in the initial infection list, treat that node as "saved" (not initially infected or removed).
2. Perform a Depth-First Search (DFS) on the graph to simulate the spread of malware given the current node is "saved".
3. Count the total number of nodes that get infected.
4. Choose the node whose removal results in the smallest number of infected nodes. If multiple nodes tie, select the smallest index.

```typescript
function minMalwareSpread(graph: number[][], initial: number[]): number {
    initial.sort((a, b) => a - b);  // Ensure we remove the smallest index in cases of ties

    // Function to perform DFS to calculate infected nodes
    const dfs = (node: number, visited: boolean[], skip: number) => {
        for (let neighbor = 0; neighbor < graph.length; ++neighbor) {
            if (graph[node][neighbor] === 1 && !visited[neighbor] && neighbor !== skip) {
                visited[neighbor] = true;
                dfs(neighbor, visited, skip);
            }
        }
    };

    let bestNode = initial[0];
    let minInfected = Infinity;

    initial.forEach(skipNode => {
        const visited = new Array(graph.length).fill(false);
        let infectedCount = 0;

        // Simulate infection spread
        initial.forEach(node => {
            if (node !== skipNode && !visited[node]) {
                visited[node] = true;
                dfs(node, visited, skipNode);
                infectedCount += visited.filter(v => v).length;
            }
        });

        if (infectedCount < minInfected) {
            minInfected = infectedCount;
            bestNode = skipNode;
        }
    });

    return bestNode;
}
```

- **Time Complexity**: O(N^3), where N is the number of nodes in the graph, due to the repeated DFS operations.
- **Space Complexity**: O(N), for the visited array.

### Approach 2: Union-Find to Identify Connected Components

**Intuition**:  
The idea is to decompose the graph into components using the Union-Find structure. Within each component, count how many nodes are infected. If a component is infected by exactly one initial node, it might provide a strategic advantage if removing one can save an entire component from infection.

**Algorithm**:  
1. Use Union-Find to find connected components.
2. Count the size of each component.
3. Count the initial nodes in each component.
4. Evaluate each initial node to determine the optimal node for removal.

```typescript
class UnionFind {
    parent: number[];
    size: number[];

    constructor(size: number) {
        this.parent = Array.from({length: size}, (_, i) => i);
        this.size = Array(size).fill(1);
    }

    find(node: number): number {
        if (this.parent[node] !== node) {
            this.parent[node] = this.find(this.parent[node]);
        }
        return this.parent[node];
    }

    union(node1: number, node2: number): void {
        let root1 = this.find(node1);
        let root2 = this.find(node2);

        if (root1 !== root2) {
            if (this.size[root1] < this.size[root2]) {
                this.parent[root1] = root2;
                this.size[root2] += this.size[root1];
            } else {
                this.parent[root2] = root1;
                this.size[root1] += this.size[root2];
            }
        }
    }

    componentSize(node: number): number {
        return this.size[this.find(node)];
    }
}

function minMalwareSpread(graph: number[][], initial: number[]): number {
    const n = graph.length;
    const unionFind = new UnionFind(n);

    // Create components using union-find
    for (let i = 0; i < n; ++i) {
        for (let j = i + 1; j < n; ++j) {
            if (graph[i][j] === 1) {
                unionFind.union(i, j);
            }
        }
    }

    const componentSize = new Map<number, number>();
    const infectedInComponent = new Map<number, number>();

    initial.forEach(node => {
        const root = unionFind.find(node);
        componentSize.set(root, (componentSize.get(root) || 0) + 1);
    });

    initial.sort((a, b) => a - b);
    let bestNode = initial[0];
    let maxSaved = -1;

    initial.forEach(node => {
        const root = unionFind.find(node);
        // Check if root is only infected by this "node"
        if (componentSize.get(root) === 1) {
            const size = unionFind.componentSize(root);
            if (size > maxSaved) {
                maxSaved = size;
                bestNode = node;
            } else if (size === maxSaved && node < bestNode) {
                bestNode = node;
            }
        }
    });

    return bestNode;
}
```

- **Time Complexity**: O(N^2), where N is the number of nodes in the graph, due to the union-find operations and creation.
- **Space Complexity**: O(N), for the union-find structure.

### Approach 3: Optimal Simulation with Influence Counting

**Intuition**:  
Instead of running potentially costly DFS simulations multiple times, we track the influence of each initially infected node across components within a graph representation. The idea is to assign credits for "saving" nodes based on the number of components uniquely infected by a single node.

**Algorithm**:  
1. Create a representation of graph components.
2. Mark affected nodes for each initial node.
3. Count influence and select the node maximizing "saved" nodes (nodes only infected by one node).

```typescript
function minMalwareSpread(graph: number[][], initial: number[]): number {
    const n = graph.length;
    let componentParent = new Array<number>(n);
    for (let i = 0; i < n; ++i) componentParent[i] = i;

    const find = (u: number): number => {
        if (componentParent[u] !== u) {
            componentParent[u] = find(componentParent[u]);
        }
        return componentParent[u];
    };

    const union = (u: number, v: number) => {
        componentParent[find(u)] = find(v);
    };

    // Form components
    for (let i = 0; i < n; ++i) {
        for (let j = i + 1; j < n; ++j) {
            if (graph[i][j] == 1) {
                union(i, j);
            }
        }
    }

    const componentSize = new Array<number>(n).fill(0);
    for (let i = 0; i < n; i++) {
        componentSize[find(i)]++;
    }

    const infectedInComponent = new Array<number>(n).fill(0);
    for (let node of initial) {
        infectedInComponent[find(node)]++;
    }

    let bestNode = n;
    let maxSize = -1;

    initial.sort((a, b) => a - b);
    for (let node of initial) {
        let root = find(node);
        if (infectedInComponent[root] == 1) {
            // Can potentially save this entire component
            if (componentSize[root] > maxSize) {
                maxSize = componentSize[root];
                bestNode = node;
            } else if (componentSize[root] == maxSize && node < bestNode) {
                bestNode = node;
            }
        }
    }

    return bestNode;
}
```

- **Time Complexity**: O(N^2), due to the finding of connected components.
- **Space Complexity**: O(N), for tracking respective arrays.

