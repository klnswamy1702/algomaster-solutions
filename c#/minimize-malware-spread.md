# [LeetCode 924: Minimize Malware Spread](https://leetcode.com/problems/minimize-malware-spread/)

## Table of Contents
- [Approach 1: Basic Depth-First Search (DFS)](#approach-1)
- [Approach 2: Union-Find (Disjoint Set Union)](#approach-2)

### Approach 1: Basic Depth-First Search (DFS) <a name="approach-1"></a>

**Intuition:**
The problem involves identifying and minimizing the spread of malware in connected networks. The basic approach leverages graph traversal to understand connected components and their infection levels. Using DFS, we can explore each node, marking connected components and counting malware presence to determine the node whose removal minimizes malware spread.

**Algorithm:**
1. Represent the network as a graph where nodes are computers.
2. For each node in the `initial` malware list, use DFS to mark its reachable nodes and record the size of each connected component.
3. Count the number of initially infected nodes in each connected component.
4. The goal is to identify the node, which, when removed, leaves the fewest components infected.
5. If there are nodes with equal potential reduction, choose the one with the smallest index.

```csharp
public int MinMalwareSpread(int[][] graph, int[] initial) {
    int n = graph.Length;
    bool[] visited = new bool[n];

    // Utility DFS function to mark connected components.
    void Dfs(int node, List<int> component) {
        visited[node] = true;
        component.Add(node);
        for (int nei = 0; nei < n; nei++) {
            if (graph[node][nei] == 1 && !visited[nei]) {
                Dfs(nei, component);
            }
        }
    }

    // Find components and the initial nodes in them
    Dictionary<int, List<int>> components = new Dictionary<int, List<int>>();
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            List<int> component = new List<int>();
            Dfs(i, component);
            foreach (var u in component) {
                components[u] = component;
            }
        }
    }

    Array.Sort(initial);

    int[] countMalwareInComponent = new int[n];

    foreach (int node in initial) {
        foreach (int u in components[node]) {
            countMalwareInComponent[u]++;
        }
    }

    // Choose the best node to remove
    int bestNode = -1;
    int maxSize = -1;

    foreach (int node in initial) {
        int component = components[node];
        int size = 0;
        foreach (int u in component) {
            if (countMalwareInComponent[u] == 1) {
                size++;
            }
        }
        if (size > maxSize || (size == maxSize && node < bestNode)) {
            maxSize = size;
            bestNode = node;
        }
    }

    return bestNode;
}
```

**Time Complexity:** O(V + E), where V is the number of vertices and E is the number of edges.

**Space Complexity:** O(V), for storing visited nodes, components, and malware counts.

### Approach 2: Union-Find (Disjoint Set Union) <a name="approach-2"></a>

**Intuition:**
Union-Find (also known as Disjoint Set Union, DSU) is a powerful data structure for handling partitioned sets, which can efficiently group nodes into connected components. This approach efficiently finds connected components and manages their related sizes and infection status.

**Algorithm:**
1. Initialize a Union-Find structure for the graph.
2. For each edge in the graph, union the two nodes.
3. Calculate the size of each component and track the infection counts.
4. Determine which removal of initial infection nodes results in minimal spread by examining the size of each component affectable by a single initial node.

```csharp
public class UnionFind {
    private int[] parent;
    private int[] size;

    public UnionFind(int n) {
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    public int Find(int u) {
        if (u != parent[u]) {
            parent[u] = Find(parent[u]);
        }
        return parent[u];
    }

    public void Union(int u, int v) {
        int pu = Find(u);
        int pv = Find(v);
        if (pu != pv) {
            parent[pu] = pv;
            size[pv] += size[pu];
        }
    }

    public int Size(int u) {
        return size[Find(u)];
    }
}

public int MinMalwareSpread(int[][] graph, int[] initial) {
    int n = graph.Length;
    UnionFind uf = new UnionFind(n);

    // Union connected components
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (graph[i][j] == 1) {
                uf.Union(i, j);
            }
        }
    }

    // Count malware nodes in each component
    int[] countMalwareInComponent = new int[n];
    foreach (int node in initial) {
        int root = uf.Find(node);
        countMalwareInComponent[root]++;
    }

    Array.Sort(initial);

    // Determine best node to remove
    int bestNode = -1;
    int maxSize = -1;

    foreach (int node in initial) {
        int root = uf.Find(node);
        if (countMalwareInComponent[root] == 1) { // Only one virus in this component
            int size = uf.Size(root);
            if (size > maxSize || (size == maxSize && node < bestNode)) {
                maxSize = size;
                bestNode = node;
            }
        }
    }

    return bestNode;
}
```

**Time Complexity:** O(V + E * α(V)), where α is the inverse Ackermann function, which grows very slowly.

**Space Complexity:** O(V), for the Union-Find structure.

By using these methods, we evaluate and minimize the spread of malware effectively, selecting the optimal node for removal based on component size and infection influence, providing flexibility for further optimization and more practical implementations.

