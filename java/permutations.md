# [Leetcode 46: Permutations](https://leetcode.com/problems/permutations/)

## Approaches:
1. [Recursive Backtracking](#recursive-backtracking)
2. [Iterative using Insertion](#iterative-using-insertion)

---

### Recursive Backtracking

The basic idea for generating all permutations of an array is to swap each element with every other element and then recursively call the function for the next depth. The permutations are generated by exploring the problem's decision tree depth-first. In each recursive call, we will swap elements and call the function for the next element. Once all elements are considered, we add the current permutation into our result list.

#### Intuition
- Start with the first element and generate permutations with all other elements.
- Use a recursive function to explore all permutations.
- Swap elements at each recursive level to fix one and permute the rest.
- Keep track of current permutation and used elements.
- Backtrack and undo the swap to explore different permutations.

#### Code
```java
import java.util.ArrayList;
import java.util.List;

public class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        backtrack(nums, result, new ArrayList<>(), new boolean[nums.length]);
        return result;
    }
    
    private void backtrack(int[] nums, List<List<Integer>> result, List<Integer> tempList, boolean[] used) {
        // Base case: if the current permutation is complete
        if (tempList.size() == nums.length) {
            result.add(new ArrayList<>(tempList));
        } else {
            // Iterate through each number to generate permutations
            for (int i = 0; i < nums.length; i++) {
                // If the number is already used in current permutation, skip it
                if (used[i]) continue;

                // Decision: include nums[i] in current permutation
                used[i] = true;
                tempList.add(nums[i]);
                
                // Recur to build the rest of the permutation
                backtrack(nums, result, tempList, used);

                // Backtrack: undo the decision
                used[i] = false;
                tempList.remove(tempList.size() - 1);
            }
        }
    }
}
```
#### Complexity Analysis
- **Time Complexity**: O(n * n!), where n is the length of `nums`. We have n! permutations and for each permutation, we copy the permutation list to results.
- **Space Complexity**: O(n) due to the recursion stack and storage for the permutations being created.

---

### Iterative using Insertion

This approach builds permutations iteratively by repeatedly inserting a new element into existing permutations generated so far. It makes use of lists and creates new permutations by inserting the current element in every possible position within each existing permutation.

#### Intuition
- Start with an empty permutation list.
- Gradually build it by inserting each new element into all possible positions of existing permutations.
- This process builds all permutations without recursion.

#### Code
```java
import java.util.ArrayList;
import java.util.List;

public class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        
        // Begin by adding the first number as the first permutation
        result.add(new ArrayList<>());
        
        // Process each number in the input array
        for (int num : nums) {
            List<List<Integer>> newPermutations = new ArrayList<>();
            
            // Expand each existing permutation
            for (List<Integer> perm : result) {
                // Insert current number in every possible position
                for (int i = 0; i <= perm.size(); i++) {
                    List<Integer> newPerm = new ArrayList<>(perm);
                    newPerm.add(i, num); // Insert current number
                    newPermutations.add(newPerm);
                }
            }
            
            // Update result with new permutations including the current number
            result = newPermutations;
        }
        
        return result;
    }
}
```
#### Complexity Analysis
- **Time Complexity**: O(n * n!), where n is the length of `nums`. This is because for each new number, all previous permutations are expanded.
- **Space Complexity**: O(n * n!), as we store all permutations explicitly.

Both approaches generate all permutations of an array, but the recursive backtracking approach is more classical and easier to follow for problems of this nature.

