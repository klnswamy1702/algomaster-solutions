# [Leetcode 924: Minimize Malware Spread](https://leetcode.com/problems/minimize-malware-spread/)

## Approaches
- [Approach 1: DFS for Component Identification](#approach-1-dfs-for-component-identification)
- [Approach 2: Union Find (Disjoint Set)](#approach-2-union-find-disjoint-set)

---

## Approach 1: DFS for Component Identification

### Intuition:
The problem is essentially about identifying connected components in a graph and determining the effect of removing a malware-infected node. We can use Depth First Search (DFS) to identify the size of each connected component and keep track of nodes that are initially infected.

1. First, mark all connected nodes using DFS for each unvisited node, which helps identify components.
2. For each initially infected node, simulate its removal and determine how many other nodes can be saved by using the largest saved component strategy.

### Algorithm:
1. Traverse the graph using DFS to identify components and their sizes.
2. Record infected nodes within these components.
3. Evaluate each infected node's removal impact. If multiple nodes result in the same number of saved nodes, choose the node with the smallest index.

### Time Complexity:
- **O(N^2)** due to the DFS which traverses all nodes and edges.
  
### Space Complexity:
- **O(N)** for storing visited states and component information.

```java
import java.util.*;

public class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        boolean[] visited = new boolean[n];
        List<List<Integer>> components = new ArrayList<>();
        
        for (int i = 0; i < n; ++i) {
            if (!visited[i]) {
                List<Integer> component = new ArrayList<>();
                dfs(i, graph, visited, component);
                components.add(component);
            }
        }

        int[] infectedCount = new int[components.size()];
        Map<Integer, Integer> nodeToComponent = new HashMap<>();
        
        for (int componentIndex = 0; componentIndex < components.size(); componentIndex++) {
            for (int node : components.get(componentIndex)) {
                nodeToComponent.put(node, componentIndex);
            }
        }

        for (int node : initial) {
            int componentIndex = nodeToComponent.get(node);
            infectedCount[componentIndex]++;
        }

        Arrays.sort(initial);
        int result = initial[0], maxSaved = -1;
        
        for (int node : initial) {
            int componentIndex = nodeToComponent.get(node);
            if (infectedCount[componentIndex] == 1) {
                int saved = components.get(componentIndex).size();
                if (saved > maxSaved) {
                    maxSaved = saved;
                    result = node;
                }
            }
        }
        
        return result;
    }
    
    private void dfs(int node, int[][] graph, boolean[] visited, List<Integer> component) {
        visited[node] = true;
        component.add(node);
        for (int neighbor = 0; neighbor < graph.length; ++neighbor) {
            if (graph[node][neighbor] == 1 && !visited[neighbor]) {
                dfs(neighbor, graph, visited, component);
            }
        }
    }
}
```

---

## Approach 2: Union Find (Disjoint Set)

### Intuition:
A more efficient approach than DFS is using a Union Find (Disjoint Set) data structure to determine connected components. This method efficiently merges nodes and provides component size information.

1. Use Union-Find to identify connected components.
2. Count infected nodes within each component.
3. By eliminating a node that is the only infected node within a component, maximize saved nodes.

### Algorithm:
1. Implement Union-Find to determine component connections.
2. Count the infected nodes in each component.
3. Identify the node whose removal saves the maximum nodes.

### Time Complexity:
- **O(N^2)** amortized due to the union-find operations needed for dense graph connections.

### Space Complexity:
- **O(N)** for storing parent and rank information in Union-Find.

```java
public class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        UnionFind uf = new UnionFind(n);
        
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (graph[i][j] == 1) {
                    uf.union(i, j);
                }
            }
        }
        
        int[] infectedCount = new int[n];
        for (int node : initial) {
            int root = uf.find(node);
            infectedCount[root]++;
        }
        
        Arrays.sort(initial);
        int result = initial[0], maxSaved = -1;
        
        for (int node : initial) {
            int root = uf.find(node);
            if (infectedCount[root] == 1) {
                int saved = uf.size[root];
                if (saved > maxSaved) {
                    maxSaved = saved;
                    result = node;
                }
            }
        }
        
        return result;
    }
}

class UnionFind {
    int[] parent, size;
    
    public UnionFind(int n) {
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
            size[i] = 1;
        }
    }
    
    public int find(int x) {
        if (parent[x] == x) return x;
        return parent[x] = find(parent[x]);
    }
    
    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            if (size[rootX] < size[rootY]) {
                parent[rootX] = rootY;
                size[rootY] += size[rootX];
            } else {
                parent[rootY] = rootX;
                size[rootX] += size[rootY];
            }
        }
    }
}
```

This second approach using Union-Find is often more efficient, especially for larger graphs, due to its ability to quickly merge and find connected components.

