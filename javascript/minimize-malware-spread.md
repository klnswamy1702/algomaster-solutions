# [Leetcode 924: Minimize Malware Spread](https://leetcode.com/problems/minimize-malware-spread/)

## Approaches
- [Approach 1: Brute Force](#approach-1-brute-force)
- [Approach 2: Union-Find](#approach-2-union-find)

---

## Approach 1: Brute Force

### Intuition:
The problem asks us to minimize the spread of malware after removing one node that initially contains malware. The brute force approach involves simulating the removal of each node from the initial infected list and seeing which removal yields the smallest number of infected nodes post-reduction. This involves recalculating the infected spread for each step, which can be achieved by using a Depth First Search (DFS) to count how many nodes are infected when starting from each initially infected node.

### Steps:
1. Count the number of initially infected nodes connected to each node using a DFS.
2. For each node in `initial` list:
   - Consider removing the node and calculate the size of remaining malware spread using DFS.
   - Track the node removal that results in the minimum infection.
3. Return the node whose removal led to the minimum infection. In case of a tie, return the smallest node.

### Code:
```javascript
function minimizeMalwareSpread(graph, initial) {
    initial.sort((a, b) => a - b); // Sort to manage ties by smallest index
    let N = graph.length;
    let minInfection = Infinity;
    let bestNode = initial[0];

    const dfs = (node, seen) => {
        for (let neighbor = 0; neighbor < N; neighbor++) {
            if (graph[node][neighbor] === 1 && !seen[neighbor]) {
                seen[neighbor] = true;
                dfs(neighbor, seen);
            }
        }
    };

    for (let node of initial) {
        let seen = Array(N).fill(false);
        seen[node] = true;
        for (let startNode of initial) {
            if (startNode !== node && !seen[startNode]) {
                dfs(startNode, seen);
            }
        }
        let currentInfection = seen.reduce((acc, infected) => acc + infected, 0);
        if (currentInfection < minInfection) {
            minInfection = currentInfection;
            bestNode = node;
        }
    }
    return bestNode;
}
```

### Complexity:
- **Time Complexity:** \(O(N^3)\), where \(N\) is the number of nodes, as we run DFS \(O(N)\) times and each DFS can potentially traverse all nodes.
- **Space Complexity:** \(O(N)\), additional space for the `seen` array for each DFS execution.

---

## Approach 2: Union-Find

### Intuition:
Using Union-Find (also known as Disjoint Set Union), we can group nodes into connected components. By doing this, we can efficiently calculate the size of each component and determine which initially infected node removal would minimize the overall infection. The key is to identify and understand the role of each infected node within its component.

### Steps:
1. Use Union-Find to identify components.
2. Count the nodes in each component and identify which components are infected by initially infected nodes.
3. Determine which node to remove to minimize malware spread based on component sizes and infection spread.

### Code:
```javascript
function minimizeMalwareSpread(graph, initial) {
    initial.sort((a, b) => a - b);
    const N = graph.length;
    const parent = [...Array(N)].map((_, index) => index);
    const size = Array(N).fill(1);

    const find = (x) => {
        if (parent[x] !== x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    };

    const union = (x, y) => {
        const rootX = find(x);
        const rootY = find(y);
        if (rootX !== rootY) {
            if (size[rootX] < size[rootY]) {
                parent[rootX] = rootY;
                size[rootY] += size[rootX];
            } else {
                parent[rootY] = rootX;
                size[rootX] += size[rootY];
            }
        }
    };

    for (let i = 0; i < N; i++) {
        for (let j = 0; j < N; j++) {
            if (graph[i][j] === 1) {
                union(i, j);
            }
        }
    }

    const componentSize = Array(N).fill(0);
    const infectedInComponent = Array(N).fill(0);

    for (let i = 0; i < N; i++) {
        const root = find(i);
        componentSize[root]++;
    }

    for (const node of initial) {
        const root = find(node);
        infectedInComponent[root]++;
    }

    let result = initial[0];
    let maxSize = -1;

    for (const node of initial) {
        const root = find(node);
        if (infectedInComponent[root] === 1) { 
            if (componentSize[root] > maxSize) {
                maxSize = componentSize[root];
                result = node;
            }
        }
    }

    return result;
}
```

### Complexity:
- **Time Complexity:** \(O(N^2 \cdot \alpha(N))\), where \(\alpha\) is the Inverse Ackermann function, due to the union-find operations over the adjacency matrix.
- **Space Complexity:** \(O(N)\), for tracking components, component sizes, and infections.

By using Union-Find, we achieve a more optimal solution, improving both time and space efficiency compared to the brute force method.

