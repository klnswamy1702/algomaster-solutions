# [Leetcode 355: Design Twitter](https://leetcode.com/problems/design-twitter/)

## Navigation Links
- [Approach 1: Basic Design with Direct Data Structures](#approach-1-basic-design-with-direct-data-structures)
- [Approach 2: Optimized with Min-Heap for Feed Retrieval](#approach-2-optimized-with-min-heap-for-feed-retrieval)
  
## Problem Statement
Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed. Implement the Twitter class:
- `Twitter()`: Initializes your Twitter object.
- `void postTweet(int userId, int tweetId)`: Composes a new tweet with `tweetId` by the user `userId`. Each call to this method will assign a unique `ID` to the tweet.
- `List<Integer> getNewsFeed(int userId)`: Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.
- `void follow(int followerId, int followeeId)`: The user designated by `followerId` follows the user designated by `followeeId`.
- `void unfollow(int followerId, int followeeId)`: The user designated by `followerId` unfollows the user designated by `followeeId`.

## Approach 1: Basic Design with Direct Data Structures
### Intuition
To design this problem from scratch, we need to maintain a few data structures:
- A map to store the list of tweets by each user.
- A timestamp feature to maintain the chronological order of tweets.
- A map to store the list of users each user is following.

The basic approach involves directly using hashmaps to store the tweets and the follow relationships. Each tweet will be stored along with a timestamp (or simply an increasing counter) to maintain chronological order. The news feed can be generated by combining the tweets from a user and all the users they follow by sorting them according to the timestamp.

### Code

```javascript
class Twitter {
    constructor() {
        this.timestamp = 0; // To assign unique time to each tweet
        this.tweets = new Map(); // userId -> list of [timestamp, tweetId] pairs
        this.following = new Map(); // userId -> set of userIds they are following
    }
    
    // Create a new tweet
    postTweet(userId, tweetId) {
        if (!this.tweets.has(userId)) {
            this.tweets.set(userId, []);
        }
        this.tweets.get(userId).unshift([this.timestamp++, tweetId]); // Latest tweet comes first
    }
    
    // Generate the news feed
    getNewsFeed(userId) {
        const minHeap = [];
        
        // Consider tweets of the user
        if (this.tweets.has(userId)) {
            minHeap.push(...this.tweets.get(userId));
        }
        
        // Consider tweets of users they are following
        if (this.following.has(userId)) {
            for (const followeeId of this.following.get(userId)) {
                if (this.tweets.has(followeeId)) {
                    minHeap.push(...this.tweets.get(followeeId));
                }
            }
        }
        
        // Sort tweets with latest ones first
        minHeap.sort((a, b) => b[0] - a[0]);
        
        // Return the tweetId of the 10 latest tweets
        return minHeap.slice(0, 10).map(pair => pair[1]);
    }
    
    // Start following a user
    follow(followerId, followeeId) {
        if (!this.following.has(followerId)) {
            this.following.set(followerId, new Set());
        }
        this.following.get(followerId).add(followeeId);
    }
    
    // Stop following a user
    unfollow(followerId, followeeId) {
        if (this.following.has(followerId)) {
            this.following.get(followerId).delete(followeeId);
        }
    }
}
```

### Time and Space Complexity
- `postTweet`: O(1) time and space to store a new tweet.
- `getNewsFeed`: O(N log N) time due to sorting, where N is the number of tweets considered from the user and their followees.
- `follow`/`unfollow`: O(1) time and space for updating the follow set.

## Approach 2: Optimized with Min-Heap for Feed Retrieval
### Intuition
The main bottleneck in the initial approach is sorting all the potential tweets to derive the news feed. An optimization can involve using a Min-Heap of fixed size 10 while adding tweets, allowing us to efficiently maintain only the top 10 most recent tweets.

### Code

```javascript
class Twitter {
    constructor() {
        this.timestamp = 0;
        this.tweets = new Map();
        this.following = new Map();
    }
    
    postTweet(userId, tweetId) {
        if (!this.tweets.has(userId)) {
            this.tweets.set(userId, []);
        }
        this.tweets.get(userId).unshift([this.timestamp++, tweetId]);
    }
    
    getNewsFeed(userId) {
        const minHeap = new MinPriorityQueue({ priority: (x) => x[0] });

        const addTweetsToHeap = (tweets) => {
            for (let [time, tweetId] of tweets) {
                if (minHeap.size() < 10) {
                    minHeap.enqueue([time, tweetId]);
                } else if (time > minHeap.front().element[0]) {
                    minHeap.dequeue();
                    minHeap.enqueue([time, tweetId]);
                }
            }
        }
        
        if (this.tweets.has(userId)) {
            addTweetsToHeap(this.tweets.get(userId));
        }
        
        if (this.following.has(userId)) {
            for (const followeeId of this.following.get(userId)) {
                if (this.tweets.has(followeeId)) {
                    addTweetsToHeap(this.tweets.get(followeeId));
                }
            }
        }
        
        const result = [];
        while (!minHeap.isEmpty()) {
            result.unshift(minHeap.dequeue().element[1]); // Latest first
        }
        return result;
    }
    
    follow(followerId, followeeId) {
        if (!this.following.has(followerId)) {
            this.following.set(followerId, new Set());
        }
        this.following.get(followerId).add(followeeId);
    }
    
    unfollow(followerId, followeeId) {
        if (this.following.has(followerId)) {
            this.following.get(followerId).delete(followeeId);
        }
    }
}
```

### Time and Space Complexity
- `postTweet`: O(1) time and space.
- `getNewsFeed`: O(N log K) time with heap operations, where N is the total number of tweets considered, and K is the size of the heap (10 in this case).
- `follow`/`unfollow`: O(1) time and space.

By using a Min-Heap, we efficiently maintain the latest 10 tweets for the feed, reducing the overhead of sorting a potentially large set of tweets.

