### [LeetCode Problem 924: Minimize Malware Spread](https://leetcode.com/problems/minimize-malware-spread/)

#### Approaches:
- [Approach 1: Brute Force](#approach-1-brute-force)
- [Approach 2: Union Find (Disjoint Set Union)](#approach-2-union-find-disjoint-set-union)

---

### Approach 1: Brute Force

**Intuition:**

In this method, for every node listed in `initial`, we will check what happens if we remove it. We'll simulate the spreading of malware without that node and compute the size of the spread. The node which minimizes the size of the malware spread will be the answer.

**Steps:**
1. For each node in the initial list:
   - Remove the node and simulate the spread of malware.
   - Use BFS/DFS to determine the resulting number of infected nodes.
2. Choose the node which minimizes the number of nodes infected after removal.

This approach explores every option comprehensively but is suboptimal due to redundancy in recalculating spread for every node removal.

```cpp
#include <vector>
#include <algorithm>
#include <queue>

using namespace std;

int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    int n = graph.size();
    sort(initial.begin(), initial.end()); // Sort to handle ties by smallest index
    int minSpread = n, result = initial[0];

    for (int remove : initial) {
        vector<bool> visited(n, false);

        int spread = 0;
        for (int i : initial) {
            if (i != remove && !visited[i]) {
                // BFS to count the spread of malware ignoring this node
                queue<int> q;
                q.push(i);
                visited[i] = true;
                int count = 0;

                while (!q.empty()) {
                    int node = q.front(); q.pop();
                    count++;

                    for (int j = 0; j < n; ++j) {
                        if (graph[node][j] == 1 && !visited[j]) {
                            q.push(j);
                            visited[j] = true;
                        }
                    }
                }
                spread += count;
            }
        }

        if (spread < minSpread) {
            minSpread = spread;
            result = remove;
        }
    }

    return result;
}
```

**Time Complexity:** O(n^2 + k^2 * n) where n is the number of nodes, k is the size of the initial malware list.  
**Space Complexity:** O(n) for the visited array.

---

### Approach 2: Union Find (Disjoint Set Union)

**Intuition:**

The main idea is to treat this problem as finding connected components in a graph. Each connected component can be represented by its root, and we keep track of the size of each component. For each initial malware node, we determine how many unique components it would affect and the size of these components.

**Steps:**
1. Create a union-find structure to find and union connected components.
2. For each node in the initial list, count the number of unique components it influences.
3. If removing a node spreads the malware less due to less size of its component, consider that as a candidate.
4. Choose the node which reduces the spread optimally with the tiebreaker being the smallest index.

```cpp
#include <vector>
#include <algorithm>

using namespace std;

class UnionFind {
    vector<int> parent, size;
public:
    UnionFind(int n) : parent(n), size(n, 1) {
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
        }
    }

    int find(int x) {
        if (parent[x] != x)
            parent[x] = find(parent[x]);
        return parent[x];
    }

    void unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            if (size[rootX] < size[rootY]) {
                parent[rootX] = rootY;
                size[rootY] += size[rootX];
            } else {
                parent[rootY] = rootX;
                size[rootX] += size[rootY];
            }
        }
    }

    int componentSize(int x) {
        return size[find(x)];
    }
};

int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    int n = graph.size();
    UnionFind uf(n);
    
    // Union all nodes in the graph
    for (int i = 0; i < n; ++i)
        for (int j = i + 1; j < n; ++j)
            if (graph[i][j] == 1)
                uf.unite(i, j);
                
    sort(initial.begin(), initial.end()); // Sort to handle ties by smallest index

    vector<int> malwareCount(n, 0);

    // Count malware in components
    for (int node : initial) {
        malwareCount[uf.find(node)]++;
    }

    int result = initial[0];
    int maxSaved = 0;

    for (int node : initial) {
        int root = uf.find(node);
        if (malwareCount[root] == 1) {
            int saved = uf.componentSize(root);
            // Select the node which gives the max saved component size
            if (saved > maxSaved) {
                maxSaved = saved;
                result = node;
            }
        }
    }
    return result;
}
```

**Time Complexity:** O(n^2) due to union operations, but optimized by path compression and union by size.
**Space Complexity:** O(n) for parent and size arrays in the DSU structure.

This approach significantly improves efficiency by leveraging the union-find data structure, which is ideal for handling connected components in undirected graphs.

