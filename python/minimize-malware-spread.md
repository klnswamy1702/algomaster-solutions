# [Leetcode 924: Minimize Malware Spread](https://leetcode.com/problems/minimize-malware-spread/)

## Approaches
- [Approach 1: Brute Force](#approach-1-brute-force)
- [Approach 2: DFS to find components](#approach-2-dfs-to-find-components)
- [Approach 3: Union-Find to find components](#approach-3-union-find-to-find-components)

### Approach 1: Brute Force

**Intuition:**
- The brute force approach involves removing each node listed in the initial infected nodes and re-evaluating the number of affected nodes in the graph to determine which one minimizes the total spread.
- We simulate the removal of each node in the initial infected list one by one, remove the node and its edges, and evaluate the resulting new graph.

**Steps:**
1. For each node in the initial list, remove it from the graph.
2. Use DFS or BFS to count the number of other infected nodes that we can't reach starting from the remaining infected ones.
3. Restore the removed node and repeat for the next node in the initial list.
4. Keep track of the minimum spread.

```python
def minMalwareSpread(graph, initial):
    # Sort initial to choose minimum index in case of a tie
    initial.sort()
    N = len(graph)
    min_spread, result = float('inf'), -1
    
    def dfs(node, visited):
        stack = [node]
        while stack:
            u = stack.pop()
            for v in range(N):
                if graph[u][v] == 1 and v not in visited:
                    visited.add(v)
                    stack.append(v)

    # Try removing each initial node
    for node in initial:
        visited = set(initial)
        visited.remove(node)
        for v in initial:
            if v not in visited:
                dfs(v, visited)
        if len(visited) < min_spread:
            min_spread = len(visited)
            result = node
    
    return result
```

- **Time Complexity:** O(N^3), where N is the number of nodes.
- **Space Complexity:** O(N) due to storing visited nodes.

### Approach 2: DFS to find components

**Intuition:**
- Find all connected components in the graph.
- Count how many initial nodes are in each component. If any component contains exactly one initial node, it is a candidate for removal.

**Steps:**
1. Perform a DFS to find components and their sizes.
2. Count the number of initial nodes in each component.
3. Choose the node that, when removed, reduces the infection spread the most, prioritizing larger components with a single initial node.

```python
def minMalwareSpread(graph, initial):
    N = len(graph)
    visited = [False] * N
    components = []
    
    def dfs(node, comp):
        stack = [node]
        while stack:
            u = stack.pop()
            if visited[u]:
                continue
            visited[u] = True
            comp.append(u)
            for v in range(N):
                if graph[u][v] == 1 and not visited[v]:
                    stack.append(v)

    # Find all components
    for i in range(N):
        if not visited[i]:
            comp = []
            dfs(i, comp)
            components.append(comp)
    
    # Count initial nodes in each component
    count_infected = {i: 0 for i in range(len(components))}
    node_to_comp = {n: i for i, comp in enumerate(components) for n in comp}
    
    for node in initial:
        count_infected[node_to_comp[node]] += 1
    
    # Determine the best node to remove
    result = min(initial)
    max_saved = 0
    for node in initial:
        comp_idx = node_to_comp[node]
        if count_infected[comp_idx] == 1: # Only one infected in the component
            num_saved = len(components[comp_idx]) # The size of the component
            if num_saved > max_saved:
                max_saved = num_saved
                result = node
            elif num_saved == max_saved:
                result = min(result, node)
    
    return result
```

- **Time Complexity:** O(N^2), where N is the number of nodes.
- **Space Complexity:** O(N) due to storing visited nodes and components details.

### Approach 3: Union-Find to find components

**Intuition:**
- Use a Union-Find data structure to create and analyze connected components for a more optimal partitioning compared to DFS.

**Steps:**
1. Implement Union-Find for path compression and quick union.
2. Identify components and sizes.
3. Similar to the DFS approach, find which node can be removed to maximize affected node reduction.

```python
class UnionFind:
    def __init__(self, size):
        self.parent = list(range(size))
        self.rank = [1] * size
    
    def find(self, u):
        if u != self.parent[u]:
            self.parent[u] = self.find(self.parent[u])
        return self.parent[u]
    
    def union(self, u, v):
        rootU = self.find(u)
        rootV = self.find(v)
        if rootU != rootV:
            if self.rank[rootU] > self.rank[rootV]:
                self.parent[rootV] = rootU
            elif self.rank[rootU] < self.rank[rootV]:
                self.parent[rootU] = rootV
            else:
                self.parent[rootV] = rootU
                self.rank[rootU] += 1

def minMalwareSpread(graph, initial):
    N = len(graph)
    uf = UnionFind(N)
    
    # Union components
    for u in range(N):
        for v in range(N):
            if graph[u][v] == 1:
                uf.union(u, v)
    
    # Calculate sizes of components
    size = [0] * N
    for u in range(N):
        root = uf.find(u)
        size[root] += 1
    
    # Count initial infections per component
    infected_count = [0] * N
    for node in initial:
        root = uf.find(node)
        infected_count[root] += 1
    
    # Determine the best node to remove
    result = min(initial)
    max_saved = 0
    for node in initial:
        root = uf.find(node)
        if infected_count[root] == 1: # Only one infection in the component
            if size[root] > max_saved:
                max_saved = size[root]
                result = node
            elif size[root] == max_saved:
                result = min(result, node)
    
    return result
```

- **Time Complexity:** O(N^2 α(N)), where α is the inverse Ackermann function, nearly constant.
- **Space Complexity:** O(N) due to the Union-Find data structures.

Each solution improves progressively, leveraging more sophisticated graph algorithms and data structures. The Union-Find approach offers a balance between clarity and performance.

