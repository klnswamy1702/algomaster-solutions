# [924. Minimize Malware Spread](https://leetcode.com/problems/minimize-malware-spread/)

## Approaches:

1. [Basic Approach: DFS with Recursion](#basic-approach-dfs-with-recursion)
2. [Optimized Approach: Union-Find Data Structure](#optimized-approach-union-find-data-structure)

---

### Basic Approach: DFS with Recursion

**Intuition:**

The problem can be interpreted as finding which node, when removed, results in the most significant reduction of infected nodes. Using Depth First Search (DFS), we can identify all connected components of the graph and determine how many nodes within these components are affected. For any node in the initial list, calculate the effect of its removal by counting the infected nodes within its component.

**Steps:**

1. Represent the graph using an adjacency matrix.
2. Use DFS to find all nodes in the connected components of infected nodes.
3. For each node in the initial infected list, calculate how many nodes it can "save" if removed.
4. Choose the node that maximizes the number of nodes saved. If multiple nodes yield the same result, select the node with the smallest index.

```go
func minMalwareSpread(graph [][]int, initial []int) int {
    // Sort the initial array to ensure ties are broken by node index
    sort.Ints(initial)
    
    n := len(graph)
    visited := make([]bool, n)
    component := make([]int, n)
    componentSize := make(map[int]int)
    
    // Count infected nodes for each component
    infectedInComponent := make(map[int]int)
    currentComponent := 0
    
    var dfs func(int)
    dfs = func(node int) {
        visited[node] = true
        component[node] = currentComponent
        componentSize[currentComponent]++
        
        for i := 0; i < n; i++ {
            if graph[node][i] == 1 && !visited[i] {
                dfs(i)
            }
        }
    }
    
    // Group nodes into components
    for i := 0; i < n; i++ {
        if !visited[i] {
            dfs(i)
            currentComponent++
        }
    }
    
    // Record the number of initially infected in each component
    for _, node := range initial {
        infectedInComponent[component[node]]++
    }
    
    // Determine which node to remove
    maxSavedNodes := -1
    result := initial[0]
    
    for _, node := range initial {
        comp := component[node]
        if infectedInComponent[comp] == 1 { // Single infection in component
            if componentSize[comp] > maxSavedNodes {
                maxSavedNodes = componentSize[comp]
                result = node
            } else if componentSize[comp] == maxSavedNodes && node < result {
                result = node
            }
        }
    }
    
    return result
}
```

**Time Complexity:** O(N^2), where N is the number of nodes in the graph due to visiting each edge in DFS.

**Space Complexity:** O(N), for storing visited nodes and component information.

---

### Optimized Approach: Union-Find Data Structure

**Intuition:**

Using the Union-Find data structure, we can efficiently manage the connected components, enabling us to keep track of component sizes and determine the impact of removing a node with minimal overhead. This approach helps efficiently find and union operations, perfect for analyzing connected components in graphs.

**Steps:**

1. Implement Union-Find for managing connected components.
2. For each node in the initial infected list, determine the component it belongs to.
3. Use Union-Find to unite nodes and track the component sizes.
4. Calculate the nodes saved similarly as the previous approach but with more efficient component size tracking.

```go
type UnionFind struct {
    parent, size []int
}

func NewUnionFind(n int) *UnionFind {
    parent := make([]int, n)
    size := make([]int, n)
    for i := 0; i < n; i++ {
        parent[i] = i
        size[i] = 1
    }
    return &UnionFind{parent, size}
}

func (uf *UnionFind) find(x int) int {
    if uf.parent[x] != x {
        uf.parent[x] = uf.find(uf.parent[x])
    }
    return uf.parent[x]
}

func (uf *UnionFind) union(x, y int) {
    rootX, rootY := uf.find(x), uf.find(y)
    if rootX != rootY {
        if uf.size[rootX] > uf.size[rootY] {
            uf.parent[rootY] = rootX
            uf.size[rootX] += uf.size[rootY]
        } else {
            uf.parent[rootX] = rootY
            uf.size[rootY] += uf.size[rootX]
        }
    }
}

func minMalwareSpread(graph [][]int, initial []int) int {
    n := len(graph)
    uf := NewUnionFind(n)
    
    // Connect nodes using Union-Find
    for i := 0; i < n; i++ {
        for j := 0; j < n; j++ {
            if graph[i][j] == 1 {
                uf.union(i, j)
            }
        }
    }
    
    // Track infected count per component
    infectedCount := make([]int, n)
    for _, node := range initial {
        root := uf.find(node)
        infectedCount[root]++
    }
    
    result := initial[0]
    maxSaved := -1
    
    for _, node := range initial {
        root := uf.find(node)
        if infectedCount[root] == 1 {
            savedNodes := uf.size[root]
            if savedNodes > maxSaved || (savedNodes == maxSaved && node < result) {
                maxSaved = savedNodes
                result = node
            }
        }
    }
    
    return result
}
```

**Time Complexity:** O(N^2), due to iterating through the matrix to union connections.

**Space Complexity:** O(N), to maintain Union-Find arrays.

This problem demonstrates graph connectivity analysis utilizing DFS and Union-Find structures, showcasing different methods to achieve the desired results based on inherent graph properties.

